package org.wartremover

import tools.nsc.Global
import reflect.api.Universe
import reflect.macros.Context
import scala.util.matching.Regex

import scala.meta.inputs.Position

trait WartTraverser {
  def apply(u: WartUniverse): u.Traverser

  lazy val className = this.getClass.getName.stripSuffix("$")
  lazy val wartName = className.substring(className.lastIndexOf('.') + 1)

  def asMacro(c: Context)(expr: c.Expr[Any]): c.Expr[Any] = {
    import c.universe._

    object MacroUniverse extends WartUniverse {
      val universe: c.universe.type = c.universe
      def error(pos: universe.Position, message: String) = c.error(pos, message)
      def warning(pos: universe.Position, message: String) = c.warning(pos, message)
      val excludes: List[String] = List.empty // TODO: find a sensible way to initialize this field with useful data
    }

    apply(MacroUniverse).traverse(expr.tree)

    expr
  }

  def asAnnotationMacro(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {
    import c.universe._

    val block = Block(annottees.map(_.tree).toList, Literal(Constant(())))
    c.typeCheck(block)

    annottees.foreach { expr =>
      asMacro(c)(expr)
    }

    c.Expr[Any](block)
  }

  def compose(o: WartTraverser): WartTraverser = new WartTraverser {
    def apply(u: WartUniverse): u.Traverser = {
      new u.Traverser {
        override def traverse(tree: u.universe.Tree): Unit = {
          WartTraverser.this(u).traverse(tree)
          o(u).traverse(tree)
        }
      }
    }
  }

  def isSynthetic(u: WartUniverse)(t: u.universe.Tree): Boolean = {
    // Unfortunately, Scala does not mark accessors as Synthetic (even though the documentation claims that they do).
    // A manually crafted getter/setter does not deserve a GETTER/SETTER flag in Scala compiler's eyes, so we can
    // "safely" rely on this
    Option(t.symbol).map(s => s.isSynthetic || (s.isTerm && s.asTerm.isAccessor)).getOrElse(false)
  }

  def isPrimitive(u: WartUniverse)(t: u.universe.Type): Boolean =
    t <:< u.universe.typeOf[Boolean] ||
    t <:< u.universe.typeOf[Byte] ||
    t <:< u.universe.typeOf[Short] ||
    t <:< u.universe.typeOf[Char] ||
    t <:< u.universe.typeOf[Int] ||
    t <:< u.universe.typeOf[Long] ||
    t <:< u.universe.typeOf[Float] ||
    t <:< u.universe.typeOf[Double]


  def hasTypeAscription(u: WartUniverse)(tree: u.universe.ValOrDefDef) = {
    /*
     * A shameless hack, according to Scala specification Position should be
     * transparent (isTransparent == true) if it is generated by compiler (either entirely
     * or partially), but there might be a bug somewhere that tree.tpt.pos.isTransparent
     * does not work.
     *
     * The idea behind hack is simple, when scala compiler generates a tree it simply calls
     * focus on its owner. focus simply returns the end of the owner's position.
     */
    tree.pos.endOrPoint != tree.tpt.pos.startOrPoint
  }

  private def hasAccess(u: WartUniverse)(t: u.universe.ValOrDefDef, p: u.universe.Symbol => Boolean): Boolean = {
    // If this a field, then look at the getter's visibility
    val symbol = if(!t.symbol.isMethod && (t.symbol.owner.isType || t.symbol.owner.isModule)) {
      t.symbol.asTerm.getter
    } else t.symbol

    p(symbol)
  }

  def isPublic(u: WartUniverse)(t: u.universe.ValOrDefDef): Boolean = {
    hasAccess(u)(t, _.isPublic)
  }

  def isPrivate(u: WartUniverse)(t: u.universe.ValOrDefDef): Boolean = {
    hasAccess(u)(t, s => s.isPrivate)
  }

  def wasInferred(u: WartUniverse)(t: u.universe.TypeTree): Boolean =
    t.original == null

  def isWartAnnotation(u: WartUniverse)(a : u.universe.Annotation) : Boolean = {
    import u.universe._
    a.tpe <:< typeTag[java.lang.SuppressWarnings].tpe &&
      a.javaArgs.exists {
        case Tuple2(_, ArrayArgument(args)) => args.exists {
          case LiteralArgument(Constant(arg)) => arg == className
        }
        case _ => false
      }
  }

  def hasWartAnnotation(u: WartUniverse)(tree: u.universe.Tree) = {
    import u.universe._
    tree match {
      case t: ValOrDefDef =>
        t.symbol.annotations.exists(isWartAnnotation(u)) ||
          (t.symbol != null && t.symbol.isTerm && t.symbol.asTerm.isAccessor &&
            t.symbol.asTerm.accessed.annotations.exists(isWartAnnotation(u)))
      case t: ImplDef => t.symbol.annotations.exists(isWartAnnotation(u))
      case t => false
    }
  }

  def error(u: WartUniverse)(pos: u.universe.Position, message: String): Unit = u.error(pos, message, wartName)

  def warning(u: WartUniverse)(pos: u.universe.Position, message: String): Unit = u.warning(pos, message, wartName)
}

trait WartTraverser_ {
  import scala.meta._
  import scala.meta.transversers._
  import scala.meta.prettyprinters.Options._

  lazy val className = this.getClass.getName.stripSuffix("$")

  final def run(tree: Tree): List[WartResult] =
    traverse(tree)(wartAnnotationMatcher orElse matcher)

  val matcher: PartialFunction[Tree, TraverseResult]

  protected sealed abstract class TraverseResult
  protected final case class TError(msg: String) extends TraverseResult
  protected final case class TWarning(msg: String) extends TraverseResult
  protected case object TSkip extends TraverseResult
  protected case object TContinue extends TraverseResult

  protected def err(msg: String): TraverseResult = TError(msg)
  protected def warn(msg: String): TraverseResult = TWarning(msg)
  protected def skip: TraverseResult = TSkip
  protected def continue: TraverseResult = TContinue

  private def traverse(tree: Tree)(fn: PartialFunction[Tree, TraverseResult]): List[WartResult] = {
    val buf = scala.collection.mutable.ListBuffer[WartResult]()
    object traverser extends Traverser {
      override def apply(tree: Tree): Unit =
        if (fn.isDefinedAt(tree))
          fn(tree) match {
            case TSkip => ()
            case TContinue => super.apply(tree)
            case TError(msg) =>
              buf += WartError(msg, tree.pos)
              super.apply(tree)
            case TWarning(msg) =>
              buf += WartWarning(msg, tree.pos)
              super.apply(tree)
          }
        else
          ()
    }
    traverser(tree)
    buf.toList
  }

  private def isWartAnnotation(a : Mod) : Boolean = a match {
    case Mod.Annot(Term.Apply(
      Ctor.Ref.Name("SuppressWarnings"),
      Seq(Term.Apply(Term.Name("Array"), args)))) =>

      args.exists {
        case Lit(name) => name == className
        case _ => false
      }
    case _ => false
  }

  private val wartAnnotationMatcher: PartialFunction[Tree, TraverseResult] = {
    case Defn.Val(mods, _, _, _) if mods.exists(isWartAnnotation) => skip
    case Defn.Var(mods, _, _,  _) if mods.exists(isWartAnnotation) => skip
    case Defn.Def(mods, _, _, _, _, _) if mods.exists(isWartAnnotation) => skip
    case Defn.Macro(mods, _,  _,  _, _, _) if mods.exists(isWartAnnotation) => skip
    case Defn.Type(mods, _, _, _) if mods.exists(isWartAnnotation) => skip
    case Defn.Class(mods, _,  _, _, _) if mods.exists(isWartAnnotation) => skip
    case Defn.Trait(mods, _, _,  _, _) if mods.exists(isWartAnnotation) => skip
    case Defn.Object(mods, _, _) if mods.exists(isWartAnnotation) => skip
  }
}

object WartTraverser {
  def sumList(u: WartUniverse)(l: List[WartTraverser]): u.Traverser =
    l.reduceRight(_ compose _)(u)
}

trait WartUniverse {
  val universe: Universe
  type Traverser = universe.Traverser
  type TypeTag[T] = universe.TypeTag[T]
  protected def error(pos: universe.Position, message: String): Unit
  protected def warning(pos: universe.Position, message: String): Unit
  def error(pos: universe.Position, message: String, wartName: String): Unit =
    error(pos, s"[wartremover:$wartName] $message")
  def warning(pos: universe.Position, message: String, wartName: String): Unit =
    warning(pos, s"[wartremover:$wartName] $message")
}


trait WartUniverse_ {
  def error(pos: Position, message: String): Unit
  def warning(pos: Position, message: String): Unit
}

sealed abstract class WartResult
final case class WartError(msg: String, pos: Position) extends WartResult
final case class WartWarning(msg: String, pos: Position) extends WartResult
